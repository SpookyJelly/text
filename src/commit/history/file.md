---
layout: git
title: "파일로 이력을 관리하는 방법"
keyword: "파일 관리 방법, 파일복사, 변화된 부분들, 파일작업"
description: "깃이 없었던 시절의 고전적인 파일의 이력관리 방법에 대해서 알아봅니다. 파일복사, 파일관리 등의 불편함을 확인합니다."
breadcrumb:
- "commit"
- "history"
- "file"
---

# 파일 관리 방법
---
먼저 `깃`이 없던 시절, `전통적인` 파일의 이력 관리 방법을 알아봅시다.  

<br>

## 파일작업
---
21세기는 모든 작업들이 컴퓨터를 통하여 이루어 집니다. 그리고, 이러한 작업들은 파일이라는 형식으로 저장장치에 기록됩니다.  

파일에 코드를 작성을 하다가, 이것이 완료 되었다고 할때 저장 기록을 합니다.  

<br>

## 파일복사
---
완성된 파일에 수정이 발생하였습니다. 직접 완성된 파일을 직접 수정을 할 수도 있지만, 만일을 대비하여 우리는 원본 파일을 다른이름으로 복사해 둡니다.  
이러한 복사는 파일에 많은 수정작업이 예상되거나, 이전과 다른 작업들이 있는 경우 자주 행하여 집니다.

파일을 `복사`합니다.  
그리고 복사한 파일에는 `추가`하거나 `변경`하고 싶은 내용을 수정합니다. 그리고 다시 저장을 합니다.
우리는 이제 2개의 파일이 존재합니다.

<br>

## 수많은 파일들
---
한번의 수정만 있다고 할때 2개의 파일은 크게 문제가 되지 않습니다.  

문제는 계속해서 파일의 수정이 발생하는 것입니다. 그리고 우리는 만일을 대비하여 이러한 파일의 변화 과정을 기록해 두어야 한다고 가정해 봅시다.  

우리는 파일이 수정되는 횟수 만큼 수많은 파일을 가지게 될 것입니다. 내용의 변된 부분을 관리하는 것과 더불어 파일 관리도 필요해 집니다.  

파일이 많아지게 되면, 컴퓨터의 용량도 커지고 내용도 많이 중복되게 됩니다.  
컴퓨터 자원의 낭비라는 부작용이 발생됩니다.  

![파일 복사로 파일 관리](./img/git_file_history.png)

<br>

## 변화된 부분
---
그럼 컴퓨터의 자원을 효율적으로 사용하면서, 파일의 내용을 어떻게 관리를 해야 하는것이 좋을까요?  

바로 그것은 `새로 변경된 부분`만 추출하여 저장을 하는 것입니다.  

깃은 파일의 변화된 부분을 감지하여 이를 `동일한 파일`로 관리 합니다.  
내용의 변화는 기록이 되지만, 하나의 파일만 존재하기 때문에 수정에 따른 수많은 파일을 관리할 필요가 없습니다.  

깃은 `시간에 따라 변화되는 내용`만 관리하고, 코드가 변화된 `시간 순서`에 따라서 영구적으로 저장합니다.  
이를 `커밋`이라고 합니다.  

깃으로 파일 관리  
![깃으로 파일 관리](./img/git_file_commit.png) 

<br>

## 관리의 편리성
---
깃은 복잡한 구조의 파일을 관리하지 않고도 모든 이력을 하나의 파일로 관리 할 수 있다는 점에서 매우 유용합니다.

그럼 깃은 어떻게 하나의 파일로 여러 변화를 기록하고 관리 할 수 있는 것일까요?  
이는 커밋을 생성할때 서로 연관된 링크고리를 가지고 있다는 점입니다.  

커밋은 `부모 커밋(parent commit)`을 기반으로 변화된 부분만 `새로운 커밋`으로 생성합니다.  
그리고 커밋은 내용의 `시간적 변화`도 함께 저장합니다.  

이러한 장점으로 수많은 개발자가 코드의 변화기록을 `깃`으로 관리하고 있습니다.  

<br>