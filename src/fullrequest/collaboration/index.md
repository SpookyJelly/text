---
layout: home
title: "Git 교과서"
description: "버전 관리 시스템의 이해와 설치부터 커밋, 브랜치, 임시 처리, 병합, 복귀, 서브모듈, 태그까지
깃, 소스트리, 깃허브로 실습하며 기본기를 탄탄하게 다진다!"
keyword: "git, 깃사용법, 깃허브, 소스트리, 깃교과서"
---
# 협업
깃을 사용하는 최종적인 목적은 협업입니다. 협업은 다른 개발자와 코드를 공유하고 이를 개선해 나아가는 공동 작업입니다.

## 공개 작업
깃을 이용한 코드의 작성은 로컬 저장소에서 이루어집니다. 각 로컬 저장소는 다시 원격 저장소로 푸시되고 병합이 이루어집니다. 하지만 이러한 원격 저장소 중심의 개발을 하기 위해서는 프로젝트에 권한이 있는 사설(private) 프로젝트여야 합니다.

하지만 오픈 소스와 같이 불특정 다수의 개발자를 대상으로 프로젝트를 하기 위해서는 좀 더 특별한 기능이 필요합니다. 여러 사람들에게 소스 코드의 접근 권한 뿐만 아니라 수정 권한도 같이 부여해주어야 하기 때문입니다.

## 사례 1
깃허브에 있는 오픈 소스를 하나 사용하고 있습니다. 하지만 해당 코드에 일부 버그를 발견했습니다. 해당 오픈 소스 개발자에게 버그 내용을 통보하고 코어 개발자가 수정해주기를 기다릴 수밖에 없습니다. 언제 수정해줄지는 모릅니다.

그래서 직접 코드를 수정하여 버그를 해결하였습니다. 수정된 코드는 본인만 가지고 있고, 메인 프로젝트에는 아직 반영되지 않았습니다. 만일 오픈 소스 프로젝트가 업그레이드되고, 코드를 재설치하고자 한다면 자신이 수정한 코드를 매번 페치해주어야 합니다.

이런 경우, 자신의 수정 코드를 메인 코드에 페치하고 싶을 것입니다. 페치하기 위해서는 해당 프로젝트의 수정 권한이 있어야 하는데, 본인에게는 그러한 권한이 없습니다. 이런 경우를 대비하여 깃허브는 포크와 풀-리퀘스트를 서비스를 제공합니다.

## 자동 이슈
메인 프로젝트를 포크한 후에 포크 저장소에 자신의 코드를 페치합니다. 수정된 포크 저장소를 메인 저장소에 병합되도록 풀-리퀘스트 요청합니다.

풀-리퀘스트를 전송하면 원 저장소에서는 자동으로 이슈(issue)가 생성됩니다. 관리자는 이렇게 요청받은 풀-리퀘스트를 원래의 소스에 병합을 결정합니다. 이 과정에서 많은 테스트와 대화가 오고 갑니다.

## 기여자(contributor)
자신이 수정한 코드가 풀-리퀘스트를 통하여 반영되면 자동으로 기여자 목록에 추가됩니다. 깃허브 저장소의 기여자 목록에서 확인할 수 있습니다.

개발자로서 코드를 수정하고 기여를 통하여 더 많은 개발자에게 이로움의 혜택을 줄 수 있습니다. 이러한 것들이 의미와 보람으로 오픈 소스를 참여하는 목적이 됩니다.

## 개발 경력
오픈 소스 기여자로 활동하게 되면, 개발자로서 경력에 많은 도움이 됩니다. 자신의 실력과 노력을 대외적인 활동으로 인정받을 수 있습니다.

이러한 활동 경력은 좋은 채용과 일을 구하는 데 많은 도움이 됩니다. 최신의 기술 기업들은 깃허브와 같은 저장소에서 기여자 및 코드를 검토하고 구인을 하는 경우가 늘어나고 있습니다.
